<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-09T21:43:05+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yubmun Blog</title><subtitle>안녕하세요. 곧 프론트엔드 개발자 이준엽입니다~</subtitle><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><entry><title type="html">border겹침 현상이 있다면?</title><link href="http://localhost:4000/css/bordercollapse/" rel="alternate" type="text/html" title="border겹침 현상이 있다면?" /><published>2023-04-04T00:00:00+09:00</published><updated>2023-04-04T00:00:00+09:00</updated><id>http://localhost:4000/css/bordercollapse</id><content type="html" xml:base="http://localhost:4000/css/bordercollapse/"><![CDATA[<h2 id="table을-태그를-써서-border값을-줬더니-border겹침-현상이-일어났다">table을 태그를 써서 border값을 줬더니, border겹침 현상이 일어났다.</h2>

<p>이럴땐 <code class="language-plaintext highlighter-rouge">border-collapse: collapse;</code> 속성을 주면 해결 된다.</p>

<p>간격을 넓히고 싶다면, <code class="language-plaintext highlighter-rouge">border-collapse: sepearate;</code> 주면 된다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;table&gt;</span>
  <span class="nt">&lt;th&gt;</span>가나다라<span class="nt">&lt;/th&gt;</span>
  <span class="nt">&lt;tr&gt;</span>
    <span class="nt">&lt;td&gt;</span>마바사<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;td&gt;</span>아자차<span class="nt">&lt;/td&gt;</span>
  <span class="nt">&lt;/tr&gt;</span>
<span class="nt">&lt;/table&gt;</span>
</code></pre></div></div>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">th</span> <span class="p">{</span>
  <span class="nl">border-top</span><span class="p">:</span> <span class="m">1px</span> <span class="nb">solid</span> <span class="no">black</span><span class="p">;</span>
  <span class="nl">border-left</span><span class="p">:</span> <span class="m">1px</span> <span class="nb">solid</span> <span class="no">red</span><span class="p">;</span>
  <span class="nl">border-right</span><span class="p">:</span> <span class="m">1px</span> <span class="nb">solid</span> <span class="no">red</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런식으로 작성이 되어 있으면, border-left와 right 부분만, top부분보다 위로 보여지게 되는 안타까운 현상이 발생하게 된다.</p>

<p>이럴때엔, <code class="language-plaintext highlighter-rouge">&lt;th&gt;</code> 태그 밑에 HTML 요소를 추가해서 border 겹침 현상을 해결할 수 있다.</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="css" /><category term="css" /><summary type="html"><![CDATA[table을 태그를 써서 border값을 줬더니, border겹침 현상이 일어났다.]]></summary></entry><entry><title type="html">퍼블리셔 면접 후기</title><link href="http://localhost:4000/daily/publisher/" rel="alternate" type="text/html" title="퍼블리셔 면접 후기" /><published>2023-03-24T00:00:00+09:00</published><updated>2023-03-24T00:00:00+09:00</updated><id>http://localhost:4000/daily/publisher</id><content type="html" xml:base="http://localhost:4000/daily/publisher/"><![CDATA[<h1 id="면접-보고-온-후기">면접 보고 온 후기</h1>

<p>국민취업제도에서의 상담을 통해 일경험 프로그램이 있다는 사실을 알게 되었고, 연계를 통해 이력서를 넣고 면접을 보게 되었다.</p>

<p>지원한 직무는 웹 퍼블리셔 직무였고 주로 다루는 기술은 HTML, CSS, JS 등 이었다. 프론트엔드 개발자로 성장하기 위해 실무에 빨리 뛰어들고 싶은 마음이 컸기에 망설임 없이 달려갔다.</p>

<p>면접은 1분 자기소개, 이력서를 기재된 궁금한 내용 질문, 기술면접 세가지로 이루어졌고, 회사에 대한 소개와 현재 개발자 시장의 추세에 대해서도 말씀해주셨다.</p>

<h2 id="기술면접-질문">기술면접 질문</h2>

<p>CSS의 기본적인 내용에 대해서 질문해주셨고 질문 문항은 다음과 같다.</p>

<ol>
  <li>CSS를 작성했을 때, 적용되는 우선순위에 대해 말씀해주세요.</li>
  <li>display: flex 속성을 썼을 때, 자식요소가 어떻게 변하는지 말씀해주세요.</li>
  <li>align-items 의 default 값에 대해서 말씀해주세요.</li>
  <li>position 속성에 대한 설명과 default 값이 뭔지 말씀해주세요.</li>
  <li>HTML 파일에서의 태그를 가로정렬 할 때, 어떤 방법을 사용할 수 있는지 말씀해주세요.</li>
</ol>

<p>이렇게 다섯가지의 질문을 던져주셨고, 타입스크립트와 리액트를 위주로 공부하고 있던 나는, 기억나는대로 답변을 하긴 했다.</p>

<p>5번 문항은 가로정렬에 대해 아는 게 없어서, 요소들을 화면상에서 가로배치하는 방법에 대해 말씀하시는 건가요? 라고 물어봤지만, 코드 자체를 한줄로 나열하는 방법에 대해 물어본거였다고 해서, 잘 모르겠다고 했다.</p>

<h3 id="느낀점">느낀점</h3>

<p>기본적인 CSS 문항에 대해 질문이 들어와서 나름 다행이었지만, 정확하게 설명하진 못했던 것 같다. 아무래도 si 회사이다보니, output에 대한 기대가 가장 컸다고 생각했고, 나에게 부족한 부분이지 않을까란 생각이 들었다.</p>

<p>열심히 공부하고, 그에 맞는 프로젝트 결과물이 있어야 된다고 생각한다. 뭐라도 만들자는 마음가짐을 갖고 하나씩 시도해야겠다.</p>

<p>또한 기술면접에 관련된 문항이 너무 많으니, 틈틈히 차근차근 머릿속에 집어넣고 숙지해야겠다는 생각이 들었다. 개발공부를 생활화하는게 좋겠다. 그리고 꼭 기록해서 기억에 남겨야겠다.</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="daily" /><category term="daily" /><summary type="html"><![CDATA[면접 보고 온 후기]]></summary></entry><entry><title type="html">SPA, CSR, SSR에 대하여</title><link href="http://localhost:4000/javascript/spa/" rel="alternate" type="text/html" title="SPA, CSR, SSR에 대하여" /><published>2023-03-23T00:00:00+09:00</published><updated>2023-03-23T00:00:00+09:00</updated><id>http://localhost:4000/javascript/spa</id><content type="html" xml:base="http://localhost:4000/javascript/spa/"><![CDATA[<h1 id="spa">SPA</h1>
<p>Single Page Application의 약자로, 최초 한번 페이지를 전체 로딩한 후 부터 데이터만 변경해서 사용할 수 있는 웹 애플리케이션을 말한다.</p>

<p>장점으로는, 하나의 페이지로만 구성이 되어있기 때문에 페이지가 달라지며 발생하는 화면 깜빡임 현상이 없다.</p>

<p>단점으로는, 시멘틱한 마크업으로 작성해도 검색엔진에 노출이 되지 않는다는 점이 있다.</p>

<h1 id="csr">CSR</h1>
<p>Client Side Rendering 의 약자로 최초 로드시에 필요한 파일을 모두 받아오고, 사용자의 인터렉션에 따라서 클라이언트 측에서 받아와 렌더링을 해주는 방식이다.</p>

<p>장점으로는, 렌더링 속도가 빠르다는 점.</p>

<p>단점으로는, 최초 로드시에 뼈대만 다운받아지기 때문에, SEO 에 취약하다.</p>

<h1 id="ssr">SSR</h1>
<p>Server Side Rendering의 약자로, 요청시 마다 새로고침이 일어나고, 서버에 새로운 페이지를 요청하는 방식이다.</p>

<p>이미 다 만들어진 DOM 객체를 받으며, 렌더링 속도도 빠르고 SEO 에 최적화되어 있다.</p>

<p>단점으로는, 렌더링마다 서버를 거쳐서 렌더링되므로 속도가 느리다는 점이다.</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="javascript" /><category term="javascript" /><summary type="html"><![CDATA[SPA Single Page Application의 약자로, 최초 한번 페이지를 전체 로딩한 후 부터 데이터만 변경해서 사용할 수 있는 웹 애플리케이션을 말한다.]]></summary></entry><entry><title type="html">var, let, const의 차이?</title><link href="http://localhost:4000/javascript/TimeSpace/" rel="alternate" type="text/html" title="var, let, const의 차이?" /><published>2023-03-22T00:00:00+09:00</published><updated>2023-03-22T00:00:00+09:00</updated><id>http://localhost:4000/javascript/TimeSpace</id><content type="html" xml:base="http://localhost:4000/javascript/TimeSpace/"><![CDATA[<h1 id="어떤-차이가-있나">어떤 차이가 있나?</h1>

<h3 id="var">var</h3>
<p>변수 재선언과 재할당 모두 가능하며, 호이스팅이 일어난다.</p>

<p>함수 스코프를 가지고 있으며 ES5까지 사용되었다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">test2</span><span class="dl">'</span><span class="p">;</span>
<span class="c1">// 동일한 변수명으로 선언해도 에러가 나지 않는다.</span>

<span class="nx">c</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">test</span><span class="dl">'</span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">;</span>
<span class="c1">// 호이스팅으로 인해 레퍼런스 에러가 발생하지 않는다.</span>
</code></pre></div></div>

<h3 id="let">let</h3>
<p>변수 재선언은 불가능하고, 재할당은 가능하다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">test2</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// Syntax에러</span>

<span class="kd">let</span> <span class="nx">abc</span><span class="p">;</span>
<span class="nx">abc</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">apple</span><span class="dl">'</span><span class="p">;</span>
<span class="c1">// 할당을 선언 뒤에 해도 문제되지 않음.</span>
</code></pre></div></div>

<h3 id="const">const</h3>
<p>변수 재선언, 재할당 모두 불가능.</p>

<p>선언과 동시에 값을 할당해야만 함.</p>

<p>단, object자료형일 때 재할당에 대해 헷갈릴 수는 있다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// error</span>
</code></pre></div></div>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="javascript" /><category term="javascript" /><summary type="html"><![CDATA[어떤 차이가 있나?]]></summary></entry><entry><title type="html">나만보기 편한 redux 요약</title><link href="http://localhost:4000/typescript/redux/" rel="alternate" type="text/html" title="나만보기 편한 redux 요약" /><published>2023-03-21T00:00:00+09:00</published><updated>2023-03-21T00:00:00+09:00</updated><id>http://localhost:4000/typescript/redux</id><content type="html" xml:base="http://localhost:4000/typescript/redux/"><![CDATA[<p>Redux는 props drilling을 피하고 전역 상태관리를 위한 라이브러리이다.</p>

<p>사용 방법에 대해 여러 블로그와 공식문서를 참고하여 연습해봤다.</p>

<h1 id="사용-방법">사용 방법</h1>

<h2 id="1--action-을-만든다">1.  Action 을 만든다.</h2>

<p>useState를 쓰지 않는 Redux에서는 프로퍼티로 type이 들어가는 객체를 선언해야 한다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">junyub</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">JUNYUB</span><span class="dl">"</span> <span class="p">};</span>
</code></pre></div></div>

<p>action을 만드는데에는 두가지방법이 있다.</p>

<p>위처럼 object 자료형을 선언하는 방법과, 액션생성 함수를 만드는 방법이 있다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span> <span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">JUNYUB</span><span class="dl">"</span><span class="p">,</span> <span class="na">payload</span><span class="p">:</span> <span class="nx">num</span> <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>액션 생성함수를 만들어주게 되면, 항상 동일한 객체가 return 된다는 점이 다르다.</p>

<p>이 액션을 선언하면, 나중에 dispatch를 통해 스토어에 전달하게 되는데, 그때 dispatch함수 아규먼트 자리에 함수를 쓸거냐, object자료형을 쓸거냐의 차이이다.</p>

<h2 id="2--reducer를-작성한다">2.  reducer를 작성한다.</h2>

<p>하나의 state에 변경할 함수 로직들을 작성하는 reducer를 만들어야 한다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyubReducer</span><span class="p">(</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span><span class="na">count</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">switch</span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">){</span>
		<span class="k">case</span> <span class="dl">"</span><span class="s2">JUNYUB</span><span class="dl">"</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">{</span> <span class="p">...</span><span class="nx">state</span><span class="p">,</span> <span class="na">count</span><span class="p">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span> <span class="p">}</span>
		<span class="nl">default</span><span class="p">:</span>
			<span class="k">return</span> <span class="nx">state</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>reducer함수에는 파라미터가, 적용할 state가 첫번째, action 객체가 두번째이다.</p>

<p>우리가 선언했던, 액션이라는 객체가 두번째 파라미터로 들어오게되고, 선언했던 type파라미터자리가 switch문에 action.type으로 들어간게 보인다. state가 어떻게 변경될지에 따라 액션 생성을 추가하여 switch문의 case에 추가한다.</p>

<h3 id="보통-이-action-과-reducer는-redux폴더에-module-파일에-작성한다고-한다">보통 이 action 과 reducer는 redux폴더에 module 파일에 작성한다고 한다.</h3>

<p>리액트 프로젝트에서 리덕스 라이브러리를 사용한다면, 경로를 위와 같이 지정한다</p>

<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/75272740-b460-439b-92aa-05df4ad35e38/Untitled.png" alt="Untitled" /></p>

<p>지금까지 만들었던 action과 reducer들은 module.js 파일에 들어가고,</p>

<p>그 리듀서들을 스토어에 등록해야 된다.</p>

<h1 id="3-store를-만들고-reducer를-등록">3. store를 만들고, reducer를 등록</h1>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">combineReducers</span><span class="p">,</span> <span class="nx">createStore</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">redux</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">countReducer</span><span class="p">,</span> <span class="nx">reducer</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./module</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">rootReducer</span> <span class="o">=</span> <span class="nf">combineReducers</span><span class="p">({</span>
  <span class="na">reducer</span><span class="p">:</span> <span class="nx">reducer</span><span class="p">,</span>
  <span class="na">countReducer</span><span class="p">:</span> <span class="nx">countReducer</span><span class="p">,</span>
<span class="p">})</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nf">createStore</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">);</span>
</code></pre></div></div>

<p>프로젝트에서 전체적으로 store는 하나이다.</p>

<p>프로젝트에서 하나의 상태만 관리하는게 아니기 때문에, combineReducers로 정의했던 상태변경 리듀서들을 rootReducer라는데에 모아버린다.</p>

<p>위에서의 코드는 두개의 리듀서가 rootReducer에 combineReducers()함수를 통해 등록되는 것이다.</p>

<p>다시말해, 여러 리듀서가 존재하지만, 그걸 하나로 합쳐주는게 combineReducer() 함수고, 그걸 rootReducer라는 변수에 담았다.</p>

<p>그리고 store에는 rootReducer만 올라가면 모든 리듀서가 store에 올라가게 된다.</p>

<p>이렇게 하는 이유는, store를 여러개 생성할 수 없기 때문이다.</p>

<h1 id="4-상태관리를-적용할-컴포넌트에-provider-등록">4. 상태관리를 적용할 컴포넌트에 Provider 등록</h1>

<p>보통 전역상태관리에 의의가 있으니 index.js 나 app.js에 작성하긴 한다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// App.js</span>
<span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Provider</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-redux</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Main</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./components/Main</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">store</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./redux/store</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="p">=</span><span class="s">"container"</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Root<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="p">=</span><span class="s">"grid"</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Provider</span> <span class="na">store</span><span class="p">=</span><span class="si">{</span><span class="nx">store</span><span class="si">}</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="nc">Left1</span> <span class="p">/&gt;</span>
          <span class="p">&lt;</span><span class="nc">Right1</span> <span class="p">/&gt;</span>
          <span class="p">&lt;</span><span class="nc">Main</span><span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nc">Provider</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>하위 컴포넌트들인 Left1, Right1, Main 컴포넌트에서 store에 담긴 상태들을 갖고가서 쓸 수 있다.</p>

<p>Left1에 자식 컴포넌트, Right1의 자식컴포넌트 등등 app.js 파일에서 보이지 않는 자식컴포넌트들에게도 상태관리가 가능하다.</p>

<h1 id="5-useselector랑-usedispatch써서-상태관리하기">5. useSelector랑 useDispatch써서 상태관리하기</h1>

<p>Main 컴포넌트에서 상태관리를 한다고 가정하자.</p>

<p>useSelector는, 말 그대로 store에 등록되어 있는 state를 선택하는거다.</p>

<p>사용 방법은 다음과 같다</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">useDispatch</span><span class="p">,</span> <span class="nx">useSelector</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-redux</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">counterAdd</span><span class="p">,</span> <span class="nx">counterMinus</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../redux/module</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">Main</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">number</span> <span class="o">=</span> <span class="nf">useSelector</span><span class="p">((</span><span class="nx">state</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">countReducer</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">dispatch</span> <span class="o">=</span> <span class="nf">useDispatch</span><span class="p">();</span>

  <span class="nf">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">number</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span><span class="o">=&gt;</span> <span class="p">{</span><span class="nf">dispatch</span><span class="p">(</span><span class="nf">counterAdd</span><span class="p">(</span><span class="mi">5</span><span class="p">))}</span><span class="si">}</span><span class="p">&gt;</span>+<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span><span class="o">=&gt;</span> <span class="p">{</span><span class="nf">dispatch</span><span class="p">(</span><span class="nf">counterMinus</span><span class="p">(</span><span class="mi">5</span><span class="p">))}</span><span class="si">}</span><span class="p">&gt;</span>-<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>먼저, react-redux에서 useDispatch와 useSelector를 import 해와야 하고,</p>

<p>Main 컴포넌트에서</p>

<p>const number = useSelector((state) ⇒ state.countReducer.count); 한거가 보인다.</p>

<p>우리가, 리듀서를 만들때, 그 리듀서 이름이 countReducer였을거고, 그 안에 들어간 state 이름이 count 였다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nf">countReducer</span><span class="p">(</span><span class="nx">state</span><span class="o">=</span><span class="p">{</span><span class="na">count</span> <span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="nx">action</span><span class="p">){</span>
  <span class="nf">switch</span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">){</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">COUNTER</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">{</span> <span class="p">...</span><span class="nx">state</span><span class="p">,</span> <span class="na">count</span><span class="p">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span> <span class="p">}</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">MINUS</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">{</span> <span class="p">...</span><span class="nx">state</span><span class="p">,</span> <span class="na">count</span><span class="p">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">-</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span> <span class="p">}</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 쓰이니깐 리듀서 작명과, state 작명도 잘 해야된다.</p>

<p>어쨌든, 스토어에 있는 리듀서를 보고, state를 선택해서 number라는 변수에 담았다.</p>

<p>그럼 이제 리듀서에 등록되어 있던 상태변경을 어떻게 하는지 보겠다.</p>

<p>버튼이 두개있고 onclick했을때 콜백함수로 dispatch가 실행된다.</p>

<p>그리고 dispatch() 아규먼트 안에 함수 실행이 또 있다. counterAdd(5);</p>

<p>이건, 우리가 액션을 만들때 액션생성함수로 정의해서 이렇게 쓸 수 있는거다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">counterAdd</span><span class="p">(</span><span class="nx">num</span><span class="p">){</span>
	<span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">COUNTER</span><span class="dl">"</span> <span class="p">,</span> <span class="na">payload</span><span class="p">:</span> <span class="nx">num</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>counterAdd(5)라는건 결국 { type : “COUNTER” , payload: 5 } 를 dispatch로 넘겨주는 것과 똑같다.</p>

<p>여튼 저렇게 객체가 넘어가면, store에 있는 reducer에 전달이 되고 switch문에 있는 case들 중 return할 작업을 마친다음 상태를 변경해준다.</p>

<p>리덕스를 쓸 때 기억해야 할건 다섯가지</p>

<ol>
  <li>액션을 만든다. (객체로든 함수로든)</li>
  <li>리듀서를 만든다. (하나의 state를 관리할 리듀서이다)</li>
  <li>스토어에 리듀서를 등록한다 (여러개의 리듀서라면 combineReducers로 합치는 작업 필요)</li>
  <li>전역상태관리니깐 Provider 범위설정해준다.</li>
  <li>useSelector, useDispatch써서 상태 선택, 변경 진행</li>
</ol>

<p>이런 순서로 작성해주면 되고, 파일구조도 조심해서 사용하면 되겠다.</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="typescript" /><category term="typescript" /><summary type="html"><![CDATA[Redux는 props drilling을 피하고 전역 상태관리를 위한 라이브러리이다.]]></summary></entry><entry><title type="html">index signatures, keyof연산자, infer?</title><link href="http://localhost:4000/typescript/typescriptStudy/" rel="alternate" type="text/html" title="index signatures, keyof연산자, infer?" /><published>2023-03-16T00:00:00+09:00</published><updated>2023-03-16T00:00:00+09:00</updated><id>http://localhost:4000/typescript/typescriptStudy</id><content type="html" xml:base="http://localhost:4000/typescript/typescriptStudy/"><![CDATA[<h1 id="index-signatures">index signatures</h1>

<p>너무 많은 프로퍼티, 속성값들을 통일시켜야 할 때 index signatures 문법을 사용할 수 있다.</p>

<p>예를들면 object 자료형에 모든 속성 값들이 string 타입을 가져야 한다고 가정했을 때</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">junyub</span><span class="p">:</span> <span class="p">{</span> <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span> <span class="p">:</span> <span class="p">{</span> <span class="nl">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">junyub</span><span class="dl">"</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="dl">"</span><span class="s2">30</span><span class="dl">"</span> <span class="p">}</span>
</code></pre></div></div>

<p>이런식으로, 프로퍼티의 이름과 타입을 작성하여 타입지정이 이루어졌는데 name, age 따로따로 부여해줄게 아니라 한번에도 부여가 가능하다는 것이다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">JunYub</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="na">key</span><span class="p">:</span> <span class="kr">string</span><span class="p">]:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">obj</span><span class="p">:</span> <span class="nx">JunYub</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">junyub</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="dl">"</span><span class="s2">30</span><span class="dl">"</span> <span class="p">}</span>
</code></pre></div></div>

<p>type JunYub은 모든 string 타입을 갖는 key 에 값의 타입을 string으로 지정했다.</p>

<p>때문에 object 자료형에서 어떤 string으로 쓰여지는 프로퍼티 key 라면 모두 값의 자료형을 string 타입을 갖는다는 것이다.</p>

<p>타입은 union type, Literal type 모두 지정이 가능하다.</p>

<p>타입이 Literal type, union type도 지정이 가능하다 했으니 다음 object도 정의할 수 있다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">MyType</span> <span class="p">{</span>
	<span class="dl">"</span><span class="s2">font-size</span><span class="dl">"</span><span class="p">:</span> <span class="nx">MyType</span> <span class="o">|</span> <span class="kr">number</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">obj</span><span class="p">:</span> <span class="nx">MyType</span> <span class="p">{</span>
  <span class="dl">"</span><span class="s2">font-size</span><span class="dl">"</span> <span class="p">:</span> <span class="p">{</span>
		<span class="dl">"</span><span class="s2">font-size</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
			<span class="dl">"</span><span class="s2">font-size</span><span class="dl">"</span><span class="p">:</span> <span class="kr">number</span>
		<span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 속성의 자료형도 object인 형태가 있다면, interface를 정의한 타입을 그대로 정의할 수 있다.</p>

<h1 id="keyof-연산자">keyof 연산자</h1>

<p>object 자료형에 사용하게 되면, object 타입이 갖고 있는 모든 key를 union type으로 갖게되는 연산자다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
	<span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
	<span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PersonKeys</span> <span class="o">=</span> <span class="kr">keyof</span> <span class="nx">Person</span><span class="p">;</span>
<span class="c1">// "age" | "name" 타입이 된다.</span>
</code></pre></div></div>

<p>그렇다면 위에서 사용한 index signatures 문법을 쓰면 어떤 결과가 나오나?</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
	<span class="p">[</span><span class="nx">key</span><span class="p">:</span> <span class="kr">string</span><span class="p">]:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PersonKeys</span> <span class="o">=</span> <span class="kr">keyof</span> <span class="nx">Person</span><span class="p">;</span>
<span class="c1">// string | number 타입이 된다.</span>
</code></pre></div></div>

<h3 id="keyof-연산자로-타입-변환기-만들기">keyof 연산자로 타입 변환기 만들기</h3>

<p>만약 정의한 type을 모두 변경해야할 일이 생긴다면 다음과 같이 진행할 수 있다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Car</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">color</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">,</span>
	<span class="na">model</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">,</span>
	<span class="na">price</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">|</span> <span class="kr">number</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TypeChanger</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="nx">key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Car 로 정의한 타입 속성들을 모두 string 으로 변경하고 싶다면 아래와같이 진행하면 된다.</span>
<span class="kd">type</span> <span class="nx">NewCar</span><span class="p">:</span> <span class="nx">TypeChanger</span><span class="o">&lt;</span><span class="nx">Car</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<p>코드를 분석해보자면,</p>

<p>[key in keyof T] 라는 index signature 문법이, 모든 T의 프로퍼티 key 값들을 의미하니까</p>

<p>제네릭 타입으로 들어오는 Car라는 타입의 속성 프로퍼티 key 들이 TypeChanger의 key 값이되고, 그 값의 타입은 string이 되어, NewCar라는 타입의 속성값들은 모두 string 타입을 갖게 되는 것이다.</p>

<p>쓸일이.. 많이 있을까 싶다..</p>

<h1 id="infer-키워드">infer 키워드</h1>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Person</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="nx">infer</span> <span class="nx">R</span> <span class="p">?</span> <span class="nx">R</span> <span class="p">:</span> <span class="nx">unknown</span><span class="p">;</span>
</code></pre></div></div>

<p>제네릭 타입이 들어간다면, 개발자가 Person 타입을 사용할때 &lt;&gt; 안에 타입을 넣을 수 있었다.</p>

<p>저기서 extends는 포함하고 있느냐는 의미로 T extends string 이면, T 가 string 입니까? 라는 조건식이 될수도 있다.</p>

<p>그래서 삼항연산자를 사용한 것이고,</p>

<p>infer 키워드는, R이라고 작명한데에다 T에서 타입을 유추한대로 집어 넣는 역할을 한다.</p>

<p>위 처럼 쓰지는 않고, 보통 함수 제네릭 타입이나 배열 등에서 쓰인다고 한다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Person</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="nf">extends </span><span class="p">(</span><span class="nx">infer</span> <span class="nx">R</span><span class="p">)[]</span> <span class="p">?</span> <span class="nx">R</span> <span class="p">:</span> <span class="nx">unknown</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">NewPerson</span> <span class="o">=</span> <span class="nx">Person</span><span class="o">&lt;</span><span class="nx">boolean</span><span class="p">[]</span><span class="o">&gt;</span> <span class="c1">// NewPerson의 타입은 boolean[] 이 아닌 boolean</span>
</code></pre></div></div>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Person</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="nf">extends </span><span class="p">(</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">infer</span> <span class="nx">R</span> <span class="p">)</span> <span class="p">?</span> <span class="nx">R</span> <span class="p">:</span> <span class="nx">unknown</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">NewPerson</span> <span class="o">=</span> <span class="nx">Person</span><span class="o">&lt;</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="kr">number</span> <span class="o">&gt;</span>
<span class="c1">// NewPerson의 타입은 number</span>
</code></pre></div></div>

<p>이런식으로 사용하면 infer 키워드를 유용하게 쓸 수 있다고 한다.</p>

<p>infer 키워드 뒤에 R 이라고 써있는 건, Result를 의미하며, 다른 이름으로 사용해도 무방하긴 하다.</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="typescript" /><category term="typescript" /><summary type="html"><![CDATA[index signatures]]></summary></entry><entry><title type="html">tuple type, declare, d.ts파일?</title><link href="http://localhost:4000/typescript/typescriptStudy/" rel="alternate" type="text/html" title="tuple type, declare, d.ts파일?" /><published>2023-03-15T00:00:00+09:00</published><updated>2023-03-15T00:00:00+09:00</updated><id>http://localhost:4000/typescript/typescriptStudy</id><content type="html" xml:base="http://localhost:4000/typescript/typescriptStudy/"><![CDATA[<h1 id="tuple-type-">tuple type ..?</h1>

<p>object 자료형의 타입을 지정해줄 때,</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span><span class="p">:</span> <span class="p">{</span> <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">kim</span><span class="dl">"</span> <span class="p">}</span>
</code></pre></div></div>

<p>이런식으로 타입을 지정해줬다. 물론 type alias를 사용하거나 interface로 지정한다음 사용했던게 더 깔끔하긴 했다.</p>

<p>array의 자료형에도 object자료형 같이 들어올 타입을 지정해줄 수 있다. (물론 array 도 object 자료형이라고 볼 수도 있지만)</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">123</span><span class="dl">"</span><span class="p">,</span> <span class="mi">123</span><span class="p">];</span>
</code></pre></div></div>

<p>작성은 위와같이 하며, union type, optional 기호도 작성할 수 있다.</p>

<p>단, optional 기호는 맨뒤에 작성해주는 것이 룰이며, 중간에 끼면 말도안된다고 한다.</p>

<h3 id="spread-문법으로-index에-들어온다면-tuple-type을-어떻게-지정해주나">spread 문법으로 index에 들어온다면 tuple type을 어떻게 지정해주나?</h3>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">arr2</span><span class="p">:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="p">...</span><span class="kr">number</span><span class="p">[]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr</span><span class="p">];</span>
</code></pre></div></div>

<p>arr2의 tuple type을 저렇게 지정해줘야, 두번째 index가 spread 문법이 활용된 배열(?) 이 인덱스로 받아질 수 있다.</p>

<p>함수에서 마찬가지로 rest parameter 에도 동일하게 적용시킬 수 있겠다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span> <span class="p">(...</span><span class="nx">x</span><span class="p">:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">string</span><span class="p">,</span> <span class="p">...</span><span class="kr">number</span><span class="p">[]])</span> <span class="p">{</span>
  
<span class="p">}</span>
</code></pre></div></div>

<p>이런식으로, rest parameter의 타입도 tuple type으로 지정이 가능하다.</p>

<p>이러면 파라미터 자리에, 0번째 index가 number, 1번째 index가 string, 2번째 index부터는 쭈우우우우욱 모두 number 타입이 적용된다.</p>

<h1 id="declare-키워드">declare 키워드</h1>

<p>외부 라이브러리를 사용할때나, 작업했던 js 파일을 ts파일에서 사용한다면 타입지정이 안되어있어서 많은 오류들이 발생한다.</p>

<p>그럴때, js파일에 정의되어 있는 변수들을 사용하고싶을 때 쓰는게 declare 키워드이다.</p>

<p>이 declare 키워드는, tsc -w 로 js 파일로 변환할때 직접적으로 쓰여지는건 없다. 컴파일을 진행할때 컴파일러한테 힌트를 주는 코드라서 그렇다고 한다.</p>

<p>js 파일에서 정의된 변수들을 ts파일에서 활용하고 싶다면 declare 키워드를 써서 재정의 한 후에 사용하자.</p>

<h3 id="ts-파일에서의-특징">ts 파일에서의 특징</h3>

<p>ts파일에 정의된 변수들을 쓸 때는, declare 쓸 필요 없이 import export 문법 잘 써주면 된다.</p>

<p>근데 같은 경로에 있는 파일이라면, import export를 쓰지 않아도 변수를 갖고와서 쓸 수 있다.</p>

<p>그 이유가 ts 파일에서 정의된 애들은 다 global 변수 취급을 받기 때문이다.</p>

<p>이걸 전문용어로 <code class="language-plaintext highlighter-rouge">ambient module</code> 이라고 한다.</p>

<p>근데, import export 문법이 쓰인 파일에서는, ambient module이 적용되지 않는다. import export 문법이 쓰이면 자동으로 로컬모듈로 바뀌게 된다.</p>

<p>작업하고 있는 ts파일이 다른 파일에 영향끼치는걸 막고싶으면 export{} 를 코드에 추가해주면, 로컬모듈로 전환되니깐 그렇게 쓰면 된다.</p>

<p>그렇게 export{} 코드 추가해주고 쓰다가 글로벌로 써주고 싶다면?</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">declare</span> <span class="nb">global</span><span class="p">{</span>
  <span class="kd">type</span> <span class="nx">Junyub</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 declare 키워드를 붙여서 글로벌로 만들어줄 수 있다.</p>

<p>전에 배웠던 namespace 키워드라고 생각해도 된다고 한다. 로컬모듈에서 전역변수를 선언하는 방법이라고 생각하면 되겠다.</p>

<h1 id="dts-파일">d.ts 파일?</h1>

<p>두가지 역할을 한다.</p>

<ol>
  <li>타입정의만 하고 import 해서 쓰는 파일으로 쓰거나</li>
  <li>타입을 쭉 정리해놓는 레퍼런스로만 쓰거나</li>
</ol>

<p>1번의 역할을 할때엔, d.ts 파일이 그냥 ts파일과는 차이가 있어서, export 를 쓰지 않으면 전역변수처럼 쓰일 수 없다. ,, import export 문법을 활용해서 써야 한다.</p>

<p>2번의 역할을 할 때엔 tsconfig.json 파일에다</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="p">{</span>
    <span class="dl">"</span><span class="s2">compilerOptions</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
      <span class="p">...</span>
      <span class="dl">"</span><span class="s2">declaration</span><span class="dl">"</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>declaration: true 속성을 추가해주면 자동으로 ts 파일에 정의한 변수, 타입들이 모두 d.ts파일에 작성된다.</p>

<p>import export 없이 d.ts 파일을 글로벌 모듈로 만들고싶다면?</p>

<p>마찬가지로 tsconfig.json 파일에 속성을 추가해주면 된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="p">{</span>
    <span class="dl">"</span><span class="s2">compilerOptions</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
      <span class="p">...</span>
      <span class="dl">"</span><span class="s2">declaration</span><span class="dl">"</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="dl">"</span><span class="s2">typeRoots</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">파일경로</span><span class="dl">"</span><span class="p">],</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 쓰는것 보단, import export 문법으로 사용하는게 더 안전하다고 한다.</p>

<p>유명한 라이브러리들은 d.ts 파일에 정의해둬서 타입스크립트 프로젝트를 진행할때 타입지정해주기 용이하다고 한다. 예를들면 jQuery 같은</p>

<p>타스 공홈에서 라이브러리 이름을 검색하면 d.ts 파일을 다운받을 수 있으며, 너무나도 대표적인것들은 npm에서 제공하니깐 터미널에서 다운받을수도 있다.</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="typescript" /><category term="typescript" /><summary type="html"><![CDATA[tuple type ..?]]></summary></entry><entry><title type="html">Generic 타입에 대한 이해</title><link href="http://localhost:4000/typescript/typescriptStudy/" rel="alternate" type="text/html" title="Generic 타입에 대한 이해" /><published>2023-03-14T00:00:00+09:00</published><updated>2023-03-14T00:00:00+09:00</updated><id>http://localhost:4000/typescript/typescriptStudy</id><content type="html" xml:base="http://localhost:4000/typescript/typescriptStudy/"><![CDATA[<h1 id="generic-타입은">Generic 타입은?</h1>

<p>지정해주는 type을 파라미터 처럼 사용하는 문법이다.</p>

<p>그 타입은 &lt;&gt; 괄호 안에 넣어주면 된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">함수</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">[])</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nf">함수</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">result</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// error</span>
</code></pre></div></div>

<p>콘솔에 result 를 찍어보면, 4가 출력된다.</p>

<p>단, result의 타입은 number가 아닌 unknown으로 나온다. 타입스크립트에서 타입을 알아서 변경해주지 않기 때문이다.</p>

<p>그 말은, result가 4가 아니기에 + - 와 같은 숫자 타입에서의 계산이 안된다는 말이다.</p>

<p>때문에 result + 1 을 입력하면 에러가 발생하게 된다.</p>

<p>이러한 문제를 해결하려면 Narrowing을 잘 하면 되는데, 그걸 더 간결하게 하기 위해서 제네릭 타입이 존재한다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">T</span><span class="p">[])</span> <span class="p">:</span><span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">result1</span> <span class="o">=</span> <span class="nx">junyub</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span>
<span class="kd">let</span> <span class="nx">result2</span> <span class="o">=</span> <span class="nx">junyub</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">([</span><span class="dl">"</span><span class="s2">kim</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">park</span><span class="dl">"</span><span class="p">]);</span>
</code></pre></div></div>

<p>junyub() 함수에는 타입을 따로 지정해주지 않았다. 제네릭 타입으로 T라는 임의의 타입을 설정해뒀으며, 함수의 파라미터 타입, return 타입도 모두 동일한 타입이 되게끔 작성했다.</p>

<p>result1 이라는 변수를 선언, 할당할 때 <code class="language-plaintext highlighter-rouge">junyub&lt;number&gt;([4,2])</code> 를 보면, <number>가 들어가기에 junyub() 함수에 작성되어있던 <T> 부분에 number가 들어간다.</T></number></p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">[])</span> <span class="p">:</span><span class="kr">number</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">}</span> 
</code></pre></div></div>

<p>그럼 함수가 위와같이 동작하게 된다.</p>

<p>result2도 마찬가지로 string이 들어가니, 동일하게 동작할 것이다.</p>

<p>그렇다면,</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">:</span><span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// error</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">junyub</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>위의 코드는 왜 에러가 날까?</p>

<p>그 이유는 타입 파라미터처럼 쓰이는 제네릭 타입 작성부분에 number 가 들어갈 보장이 없기 때문이다.</p>

<p>변수를 선언, 할당할때 <number>를 작성해주는데, 개발자가 <string>이라고 쓰면 안되니깐. 타입스크립트에서는 string 타입에 +1 을 할 수 없으니깐 잘못된거라고 미리 컴파일에러가 발생하는 것이다.</string></number></p>

<p>이럴때 사용하는것도 Narrowing이지만, extends 키워드로 들어오는 타입을 제한할 수 있다.</p>

<p>이를 constraints라고 부른다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="kr">number</span><span class="o">&gt;</span> <span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">:</span><span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">junyub</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>extends 키워드를 &lt;&gt; 제네릭타입 넣는데에 작성해서 넣어주면, 상속의 개념과는 조금 다르게 동작한다.</p>

<p>T 라는 제네릭 타입에 number 타입만 오도록 제한한다 라는 의미이다.</p>

<p>interface 와 class에서 사용하는 extends와는 다르니 유의해야 한다.</p>

<h3 id="헷갈렸던-커스텀-타입-extends">헷갈렸던 커스텀 타입 extends</h3>

<p>string으로 제네릭타입을 넣으면 자릿수를 세어서 출력해주는 함수를 만든다고 가정한다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="kr">string</span><span class="o">&gt;</span> <span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">:</span><span class="kr">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span> 

<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">junyub</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">"</span><span class="s2">가나다</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p>이렇게 작성해도 훌륭하게 동작한다. 근데 extends 하는게 커스텀 타입이라면 ?</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">MyType</span> <span class="p">{</span>
  <span class="nl">length</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">junyub</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">MyType</span><span class="o">&gt;</span> <span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">MyType</span><span class="p">)</span> <span class="p">:</span><span class="kr">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">junyub</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">"</span><span class="s2">가나다</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">result2</span> <span class="o">=</span> <span class="nx">junyub</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">// error</span>
</code></pre></div></div>

<p>이게 많이 헷갈렸다.</p>

<p>type alias 든 interface든, 미리 개발자 입맛에 맞게 타입을 선언하고, 변수나 함수에 타입처럼 쓰이는 문법이 제네릭에 들어가게 됐다.</p>

<p>junyub() 함수의 제네릭 작성 부분에 <T extends="" MyType=""> 를 작성하면, T 라는 타입은 MyType에 정의된 length 속성을 복사해서 갖게 된다.</T></p>

<p>그래서 return을 작성할때 a.length라는 속성에 접근이 가능해진다. MyType이라는 인터페이스에 length라는애가 있으니깐.</p>

<p>그리고 result 변수를 선언,할당할 때 제네릭 타입에 string을 넣었다. 그렇다면 결국 string 객체에 있는 length 속성에 접근하여 a.length에 대한 값을 갖게 될것이다.</p>

<p>그러니깐, MyType 인터페이스는 junyub() 함수의 return에 length를 쓰기 위해서 그냥 넣어준 속성이다. 그리고 변수를 선언, 할당할 때 string 타입이 아닌 다른 number 타입같은게 들어오면, number 객체에는 length 속성이 없으니깐 에러가 나는 것이다.</p>

<p>그래서 <code class="language-plaintext highlighter-rouge">let result2 = junyub&lt;number[]&gt;([1,2,3,4]);</code> 로 바꿔서 입력해보니, array 자료형에는 length 속성이 존재하니깐, 에러가 나지 않았다.</p>

<h3 id="class-에서도-제네릭-타입-가능">class 에서도 제네릭 타입 가능</h3>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="nx">name</span><span class="p">;</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">어쩌구</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// any 타입이다.</span>
</code></pre></div></div>

<p>여기서 Person 클래스에 대한 인스턴스를 만들어서 할당할 때, any 타입으로만 나오게 된다.</p>

<p>제네릭 타입을 활용하고 타입을, 인스턴스가 할당될 때 적용시켜주고 싶다면 아래와 같이 작성하면 된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">name</span><span class="p">;</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="na">a</span><span class="p">:</span><span class="nx">T</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">"</span><span class="s2">어쩌구</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// string</span>
</code></pre></div></div>

<h3 id="공식문서-내용">공식문서 내용</h3>

<p>https://typescript-kr.github.io/pages/generics.html</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="typescript" /><category term="typescript" /><summary type="html"><![CDATA[Generic 타입은?]]></summary></entry><entry><title type="html">class 필드값에 쓰이는 키워드들</title><link href="http://localhost:4000/typescript/typescriptStudy/" rel="alternate" type="text/html" title="class 필드값에 쓰이는 키워드들" /><published>2023-03-13T00:00:00+09:00</published><updated>2023-03-13T00:00:00+09:00</updated><id>http://localhost:4000/typescript/typescriptStudy</id><content type="html" xml:base="http://localhost:4000/typescript/typescriptStudy/"><![CDATA[<h1 id="public--static-키워드">public , static 키워드</h1>

<p>class 문법을 사용하면 자주 보게 될 키워드들이다.</p>

<p>원하는 필드값 좌측에 public 을 써주면, 그 속성은 어디서나 쓰일 수 있다. (현재 사용한 클래스, 자식클래스 등등)</p>

<p>public을 쓰지 않아도, public을 쓴것과 똑같이 동작하는 이유는, 생략이 되어있기 때문이라고 한다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="k">public</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="k">public</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">준엽</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Junyub</span><span class="p">(</span><span class="dl">"</span><span class="s2">이준엽</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// "이준엽"</span>
<span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">김준엽</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// "김준엽"</span>
</code></pre></div></div>

<p>public을 쓰든, 안쓰든, 위와 같은 코드들은 동일하게 class 외부에서 name 필드에 접근하여 값을 수정, 변경할 수 있을 것이다.</p>

<p>필드값을 외부에서 수정, 변경이 이루어지지 않게 하려면 <code class="language-plaintext highlighter-rouge">private</code> 키워드를 작성해야한다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="k">private</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="nf">changeName</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nf">chageAge</span><span class="p">(</span><span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">준엽</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Junyub</span><span class="p">(</span><span class="dl">"</span><span class="s2">이준엽</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// "이준엽"</span>
<span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">김준엽</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// error</span>
<span class="nx">준엽</span><span class="p">.</span><span class="nf">changeName</span><span class="p">(</span><span class="dl">"</span><span class="s2">김준엽</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// "김준엽"</span>
</code></pre></div></div>

<p>private 를 사용하면, 외부에서는 변경이 불가능하기에 필드값을 변경하려면 변경 함수를 만들어줘야 한다.</p>

<p>위와 같이 changeName() 함수를 만들어서 필드값을 변경해야만 된다.</p>

<h2 id="private-public-쓰면-필드값을-더-축약해서-쓸-수-있다">private, public 쓰면 필드값을 더 축약해서 쓸 수 있다</h2>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span><span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">public</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">준엽</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Junyub</span><span class="p">(</span><span class="dl">"</span><span class="s2">준엽</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// "준엽"</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// 30</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">this.name = name;</code> 과 같은 코드를 생성자 파라미터에 public을 붙여주면 생략할 수 있다는게 장점이다.</p>

<p>인스턴스를 생성할때 public 파라미터에 관련된 데이터를 입력하지 않으면 에러가 발생한다.</p>

<p>public도 되니깐, private 키워드도 물론 축약해서 사용이 가능하다. 앞서 작성했듯이, private로 필드값을 설정하면 변경 함수를 따로 만들어서 필드값이 변경된다는 것만 알아두자.</p>

<h2 id="class-안에서-쓰는-protected-키워드">class 안에서 쓰는 protected 키워드</h2>

<p>protected 키워드도 있는데, 단어 자체로만 보면 보호해주는 느낌이다.</p>

<p>그럼, private이 있는데 뭣하러 쓰나 싶지만, 자식요소에도 필드값을 전달해주고 싶을 때 쓴다.</p>

<p>private은 범위가 클래스{} 안에서만 사용이 가능하기에, 자식요소에서는 접근이 안된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">private</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">){</span>

  <span class="p">}</span>  
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Lee</span> <span class="kd">extends</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">준엽</span><span class="dl">"</span> <span class="c1">// error;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>private가 아닌 protected 키워드를 쓰면 자식요소에서도 this.필드명으로 접근이 가능해진다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="k">protected</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">protected</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">){</span>

  <span class="p">}</span>  
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Lee</span> <span class="kd">extends</span> <span class="nc">Junyub</span> <span class="p">{</span>
  
  <span class="nf">func</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">준엽</span><span class="dl">"</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">few</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Lee</span><span class="p">(</span><span class="dl">"</span><span class="s2">이</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">few</span><span class="p">.</span><span class="nf">func</span><span class="p">());</span> <span class="c1">// "준엽"</span>
</code></pre></div></div>

<h2 id="static-키워드">static 키워드</h2>

<p>class를 통해 생성되는 인스턴스가 아님을 의미한다. 예를들면</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="k">static</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">준엽</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">가나</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Junyub</span><span class="p">();</span>
<span class="nx">가나</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// 없는 값.</span>
<span class="nx">Junyub</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// "준엽"</span>
</code></pre></div></div>

<p>Junyub이라는 class에 필드값으로 name이 선언되었지만, 인스턴스를 통해서 접근하는게 아니라, 선언한 클래스를 통해 접근할 수 있는 값에 static 키워드를 붙인다.</p>

<p>주로 자주 사용하는 상수, 변수 등에 사용한다고 한다.</p>

<h3 id="chatgpt에-static에-대해-물어본-결과">chatGPT에 static에 대해 물어본 결과</h3>
<p>타입스크립트에서 <strong><code class="language-plaintext highlighter-rouge">static</code></strong> 키워드는 클래스의 정적 멤버(static member)를 선언하는 데 사용됩니다. 정적 멤버는 클래스 자체와 연관되어 있으며, 클래스의 인스턴스가 생성되기 전에 사용할 수 있습니다. 이는 클래스의 인스턴스와는 별개로 존재하는 멤버이므로, 클래스를 생성하지 않고도 직접 호출할 수 있습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">static</code></strong> 키워드를 사용하여 선언된 정적 멤버는 클래스 이름으로 접근할 수 있습니다. 예를 들어, 다음과 같이 정적 메서드를 선언할 수 있습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">typescriptCopy</span> <span class="nx">code</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="k">static</span> <span class="nf">myStaticMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">This is a static method.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">MyClass</span><span class="p">.</span><span class="nf">myStaticMethod</span><span class="p">();</span> <span class="c1">// 'This is a static method.' 출력</span>

</code></pre></div></div>

<p>정적 멤버로는 메서드 외에도 정적 변수(static variable)를 선언할 수 있습니다. 이 변수는 클래스의 인스턴스마다 개별적으로 존재하는 인스턴스 변수와는 달리 클래스 전체에서 공유되는 변수입니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">typescriptCopy</span> <span class="nx">code</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="k">static</span> <span class="nx">myStaticVariable</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">This is a static variable.</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">myStaticVariable</span><span class="p">);</span> <span class="c1">// 'This is a static variable.' 출력</span>

</code></pre></div></div>

<p>정적 멤버는 클래스의 인스턴스와는 별개로 동작하기 때문에, 클래스 메서드 내에서 정적 멤버에 접근하기 위해서는 <strong><code class="language-plaintext highlighter-rouge">this</code></strong> 대신 클래스 이름을 사용해야 합니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">typescriptCopy</span> <span class="nx">code</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="k">static</span> <span class="nx">myStaticVariable</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">This is a static variable.</span><span class="dl">'</span><span class="p">;</span>

  <span class="k">static</span> <span class="nf">myStaticMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`The static variable is: </span><span class="p">${</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">myStaticVariable</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">MyClass</span><span class="p">.</span><span class="nf">myStaticMethod</span><span class="p">();</span> <span class="c1">// 'The static variable is: This is a static variable.' 출력</span>

</code></pre></div></div>

<p>정적 멤버는 클래스에서 자주 사용되는 상수, 유틸리티 함수, 팩토리 메서드 등을 구현할 때 유용합니다.</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="typescript" /><category term="typescript" /><summary type="html"><![CDATA[public , static 키워드]]></summary></entry><entry><title type="html">rest parameter, object자료형의 파라미터</title><link href="http://localhost:4000/typescript/typescriptStudy/" rel="alternate" type="text/html" title="rest parameter, object자료형의 파라미터" /><published>2023-03-12T00:00:00+09:00</published><updated>2023-03-12T00:00:00+09:00</updated><id>http://localhost:4000/typescript/typescriptStudy</id><content type="html" xml:base="http://localhost:4000/typescript/typescriptStudy/"><![CDATA[<p>이전 강의에서 진행했던 예제였던 것중에 중요했던 개념이다. rest parameter</p>

<p>rest parameter와 object 자료형의 파라미터는, 구조분해 할당에 대한 이해와 spread 문법에 대해 아는 것부터 필요하다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">숫자1</span><span class="p">,</span> <span class="nx">숫자2</span><span class="p">,</span> <span class="nx">숫자3</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr1</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">숫자1</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">숫자2</span><span class="p">)</span> <span class="c1">// 2</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">숫자3</span><span class="p">)</span> <span class="c1">// 3</span>

</code></pre></div></div>

<p>구조분해할당의 가장 기초적인 개념이다. 선언된 [숫자1, 숫자2, 숫자3] 이</p>

<p><code class="language-plaintext highlighter-rouge">let 숫자1 = arr1[0]</code> , <code class="language-plaintext highlighter-rouge">let 숫자2 = arr[1]</code>, <code class="language-plaintext highlighter-rouge">let 숫자3 = arr[2]</code> 과 같은 역할을 하는건데, 한줄로 표현되니깐 참 코드가 간결해진다.</p>

<p>spread 문법은</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>

<span class="kd">let</span> <span class="nx">arr3</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arr1</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr2</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">arr3</span><span class="p">);</span> <span class="c1">// [1,2,3,4,5]</span>
</code></pre></div></div>

<p>… 을 붙이면, 배열이나 객체 자료형을 풀어서 쓴다(?) 벗겨준다(?)의 의미로 이해했다.</p>

<p>때문에 arr3은, arr1의 [] arr2의 [] 이 풀어서 써졌기에, [1,2,3,4,5] 의 결과를 갖는 것이다.</p>

<p>react 를 공부할때, object 자료형의 state에 무언가 추가될때</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{...</span><span class="nx">state</span><span class="p">,</span> <span class="nx">추가되는</span> <span class="nx">속성</span><span class="p">}</span>
</code></pre></div></div>

<p>이렇게 쓰는게, 원래 object 자료형에있던 state가 앞에 풀려지고, 뒤에 추가되는 속성을 써서 다시 object자료형으로 묶어서 합쳐주는 느낌. 그게 spread 문법이다.</p>

<p>그래서, rest parameter는 무엇인가.</p>

<p>전에 풀었던 예제에서 파라미터가 하나 두개가 아닌 사용자가 입력하는 대로 받아들여질때, 3개든 100개든 상관없이 들어갈 수 있는 함수를 만든다고 할때 rest parameter를 써야한다.</p>

<p>어떻게 쓰냐면</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="p">(...</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">junyub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">));</span> <span class="c1">// [1,2,3,4,5]</span>
</code></pre></div></div>

<p>이렇게 파라미터 자리에 spread 문법을 써버리는 것이다. 그럼 a 라는 파라미터로 입력된 데이터는 array 형태로 받아진다.</p>

<p>그럼, rest parameter에 대한 타입은 어떻게 지정하는가?</p>

<p>그 데이터가 배열로 받아진다 했으니, 배열 타입 선언하듯이 만들면 된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="p">(...</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>물론 union type으로 타입을 선언해도 되겠다.</p>

<p>그렇게 받아진 여러개의 데이터를 갖는 파라미터는 forEach, map, filter 등 array 자료형에서 쓸 수 있는 메서드들을 활용할 수 있다.</p>

<p>Narrowing 할때 많이 쓰인다.</p>

<h2 id="그럼-파라미터가-object로-들어가려면">그럼 파라미터가 object로 들어가려면</h2>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">lee</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">}</span>

<span class="kd">function</span> <span class="nf">junyub</span> <span class="p">({</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">}){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">junyub</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span> <span class="c1">// "lee" \n 30</span>
</code></pre></div></div>

<p>파라미터 자리에 object 자료형이 들어오면, 구조분해할당 문법대로 써주면 된다.</p>

<p>객체를 미리 파라미터에 넣어놓으면 된다.</p>

<p>타입지정하려면 object 자료형에 타입지정하듯이 하면 된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="p">({</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">}:</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">}){</span>
  <span class="nx">블라블라</span>
<span class="p">}</span>
</code></pre></div></div>

<p>근데 객체 타입지정해줄때는 보통 type alias 나 interface 써줬으니 미리 선언해놓고 쓰면 되겠다.</p>

<h1 id="narrowing-할때-null이나-undefined-체크할때">narrowing 할때 null이나 undefined 체크할때</h1>

<p>typeof 써서 <code class="language-plaintext highlighter-rouge">if(typeof 변수 === "string")</code> 이런식으로 썼는데, 생각보다 undefined 체크하는 narrowing이 많다고 한다.</p>

<p>개발자들은 간결한 코드를 좋아해서 또 간결하게 해결하는 법을 알려줬다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if</span><span class="p">(</span><span class="nx">변수</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">변수</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">실행문</span>
<span class="p">}</span>
</code></pre></div></div>

<p>조건식에 이렇게 쓰면, 변수가 undefined면 undefined를 반환시키도록하고, string이면 실행문을 실행시켜주는 역할을 한다고 한다.</p>

<p>이전에 js 배울때 &amp;&amp; 조건연산자 쓰면 and , 양쪽 둘다 참이면 이라는 의미였는데 아마 동일하지 않을까 생각한다.</p>

<p>변수라는 애가 값이 있으면 undefined가 아닐거니깐 typeof 변수 === “string” 이라는 조건도 함께 충족되니 실행문에 접근이 될거고</p>

<p>변수라는애가 값이 없으면 undefined가 되니깐 양쪽 다 참이 안되니 실행문에 접근이 안될 것이라고 본다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Jun</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>
<span class="kd">type</span> <span class="nx">Yub</span> <span class="o">=</span> <span class="p">{</span> <span class="na">weight</span><span class="p">:</span> <span class="mi">100</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nf">lee</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">Jun</span> <span class="o">|</span> <span class="nx">Yub</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">Jun</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// 이런건 없음</span>
<span class="p">}</span>
</code></pre></div></div>

<p>typeof 연산자는, type alias 에 대한 타입을 검사해주지는 않는다. 기본 자료형만 해준다. number string boolean 같은,,</p>

<p>때문에 type alias를 쓴 타입인지에 대해 narrowing을 하려면 !</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Jun</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>
<span class="kd">type</span> <span class="nx">Yub</span> <span class="o">=</span> <span class="p">{</span> <span class="na">weight</span><span class="p">:</span> <span class="mi">100</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nf">lee</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">Jun</span> <span class="o">|</span> <span class="nx">Yub</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if</span><span class="p">(</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">Jun</span><span class="p">){</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">in</code> 키워드를 써주면 된다. 문법 자체는 <code class="language-plaintext highlighter-rouge">속성명 in object자료</code> 순으로 작성한다.</p>

<p>Jun 이라는 type에 속성이 age 니깐, age가 Jun에 있냐? , 참이라면 x 타입이 Jun 인거니깐. narrowing이 된다.</p>

<p>단, 두 type alias에서 정의된 속성이 서로 다를 때에만 <code class="language-plaintext highlighter-rouge">in</code> 키워드를 사용할 수 있다.</p>

<h3 id="class-로-사용되면-instanceof-연산자-써서-해주면-된다">class 로 사용되면 instanceof 연산자 써서 해주면 된다.</h3>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">날짜</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nf">if</span><span class="p">(</span><span class="nx">날짜</span> <span class="k">instanceof</span> <span class="nb">Date</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">참입니다</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>날짜 라고 쓴 변수가 Date class의 인스턴스이냐? 라고 조건식이 걸리는 거고, 참이면 실행문에 접근되니 이게 narrowing 이다.</p>

<p>중복되는 속성들이 있을때엔, Literal type이 있으면 narrowing이 쉽다. (당연한것)</p>

<h2 id="never-타입은-언제-쓰이는가">never 타입은 언제 쓰이는가?</h2>

<p>주로 안쓰인다. 개발자가 코드를 잘못 입력했을 때 간혹 never타입이 지정되곤 하는데, 이런 타입은 있을 수 없다는 의미로 받아들이면 된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Jun</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">Yub</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">JunYub</span> <span class="o">=</span> <span class="nx">Jun</span> <span class="o">&amp;</span> <span class="nx">Yub</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">yubmun</span><span class="p">:</span> <span class="nx">JunYub</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span> <span class="c1">// error, age는 never타입</span>
</code></pre></div></div>

<p>type alias 에서, 속성명이 중복되고 타입이 다를 때, never 타입이 적용되곤 한다.</p>

<table>
  <tbody>
    <tr>
      <td>age가 number</td>
      <td>string 타입이 아닌, never 타입이 되는 이유는 string도 되고 number도 되는 타입이 없기 때문이다.</td>
    </tr>
  </tbody>
</table>

<p>함수에서도 never 타입이 써진다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="p">()</span> <span class="p">:</span><span class="nx">never</span> <span class="p">{</span>
	
<span class="p">}</span>
</code></pre></div></div>

<p>return type 이 never 이면, return이 이루어지면 안된다는 의미로 함수가 끝나지 않는다는 것을 의미하거나 return 하는게 없는 함수임을 의미한다.</p>

<p>return 하는게 없을 때엔 never 타입보다는 void 타입을 더 많이 사용한다.</p>

<p>never 타입이 return 타입일때엔, 함수가 에러를 던지거나, 무한반복문으로 인해 끝나지 않을때 (end point 가 없을 때) 선언된다.</p>

<p>내 코드에 never 타입이 있다면, 코드를 잘못짠거라고 생각하면 되겠다.</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="typescript" /><category term="typescript" /><summary type="html"><![CDATA[이전 강의에서 진행했던 예제였던 것중에 중요했던 개념이다. rest parameter]]></summary></entry></feed>