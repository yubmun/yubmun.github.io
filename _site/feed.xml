<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-13T14:23:35+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yubmun Blog</title><subtitle>안녕하세요. 곧 프론트엔드 개발자 이준엽입니다~</subtitle><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><entry><title type="html">class 필드값에 쓰이는 키워드들</title><link href="http://localhost:4000/typescript/typescriptStudy/" rel="alternate" type="text/html" title="class 필드값에 쓰이는 키워드들" /><published>2023-03-13T00:00:00+09:00</published><updated>2023-03-13T00:00:00+09:00</updated><id>http://localhost:4000/typescript/typescriptStudy</id><content type="html" xml:base="http://localhost:4000/typescript/typescriptStudy/"><![CDATA[<h1 id="public--static-키워드">public , static 키워드</h1>

<p>class 문법을 사용하면 자주 보게 될 키워드들이다.</p>

<p>원하는 필드값 좌측에 public 을 써주면, 그 속성은 어디서나 쓰일 수 있다. (현재 사용한 클래스, 자식클래스 등등)</p>

<p>public을 쓰지 않아도, public을 쓴것과 똑같이 동작하는 이유는, 생략이 되어있기 때문이라고 한다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="k">public</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="k">public</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">준엽</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Junyub</span><span class="p">(</span><span class="dl">"</span><span class="s2">이준엽</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// "이준엽"</span>
<span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">김준엽</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// "김준엽"</span>
</code></pre></div></div>

<p>public을 쓰든, 안쓰든, 위와 같은 코드들은 동일하게 class 외부에서 name 필드에 접근하여 값을 수정, 변경할 수 있을 것이다.</p>

<p>필드값을 외부에서 수정, 변경이 이루어지지 않게 하려면 <code class="language-plaintext highlighter-rouge">private</code> 키워드를 작성해야한다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="k">private</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="nf">changeName</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nf">chageAge</span><span class="p">(</span><span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">준엽</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Junyub</span><span class="p">(</span><span class="dl">"</span><span class="s2">이준엽</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// "이준엽"</span>
<span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">김준엽</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// error</span>
<span class="nx">준엽</span><span class="p">.</span><span class="nf">changeName</span><span class="p">(</span><span class="dl">"</span><span class="s2">김준엽</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// "김준엽"</span>
</code></pre></div></div>

<p>private 를 사용하면, 외부에서는 변경이 불가능하기에 필드값을 변경하려면 변경 함수를 만들어줘야 한다.</p>

<p>위와 같이 changeName() 함수를 만들어서 필드값을 변경해야만 된다.</p>

<h2 id="private-public-쓰면-필드값을-더-축약해서-쓸-수-있다">private, public 쓰면 필드값을 더 축약해서 쓸 수 있다</h2>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span><span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">public</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">준엽</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Junyub</span><span class="p">(</span><span class="dl">"</span><span class="s2">준엽</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// "준엽"</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">준엽</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// 30</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">this.name = name;</code> 과 같은 코드를 생성자 파라미터에 public을 붙여주면 생략할 수 있다는게 장점이다.</p>

<p>인스턴스를 생성할때 public 파라미터에 관련된 데이터를 입력하지 않으면 에러가 발생한다.</p>

<p>public도 되니깐, private 키워드도 물론 축약해서 사용이 가능하다. 앞서 작성했듯이, private로 필드값을 설정하면 변경 함수를 따로 만들어서 필드값이 변경된다는 것만 알아두자.</p>

<h2 id="class-안에서-쓰는-protected-키워드">class 안에서 쓰는 protected 키워드</h2>

<p>protected 키워드도 있는데, 단어 자체로만 보면 보호해주는 느낌이다.</p>

<p>그럼, private이 있는데 뭣하러 쓰나 싶지만, 자식요소에도 필드값을 전달해주고 싶을 때 쓴다.</p>

<p>private은 범위가 클래스{} 안에서만 사용이 가능하기에, 자식요소에서는 접근이 안된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">private</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">){</span>

  <span class="p">}</span>  
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Lee</span> <span class="kd">extends</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">준엽</span><span class="dl">"</span> <span class="c1">// error;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>private가 아닌 protected 키워드를 쓰면 자식요소에서도 this.필드명으로 접근이 가능해진다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="k">protected</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="k">protected</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">){</span>

  <span class="p">}</span>  
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Lee</span> <span class="kd">extends</span> <span class="nc">Junyub</span> <span class="p">{</span>
  
  <span class="nf">func</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">준엽</span><span class="dl">"</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">few</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Lee</span><span class="p">(</span><span class="dl">"</span><span class="s2">이</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">few</span><span class="p">.</span><span class="nf">func</span><span class="p">());</span> <span class="c1">// "준엽"</span>
</code></pre></div></div>

<h2 id="static-키워드">static 키워드</h2>

<p>class를 통해 생성되는 인스턴스가 아님을 의미한다. 예를들면</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Junyub</span> <span class="p">{</span>
  <span class="k">static</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">준엽</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">가나</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Junyub</span><span class="p">();</span>
<span class="nx">가나</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// 없는 값.</span>
<span class="nx">Junyub</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// "준엽"</span>
</code></pre></div></div>

<p>Junyub이라는 class에 필드값으로 name이 선언되었지만, 인스턴스를 통해서 접근하는게 아니라, 선언한 클래스를 통해 접근할 수 있는 값에 static 키워드를 붙인다.</p>

<p>주로 자주 사용하는 상수, 변수 등에 사용한다고 한다.</p>

<h3 id="chatgpt에-static에-대해-물어본-결과">chatGPT에 static에 대해 물어본 결과</h3>
<p>타입스크립트에서 <strong><code class="language-plaintext highlighter-rouge">static</code></strong> 키워드는 클래스의 정적 멤버(static member)를 선언하는 데 사용됩니다. 정적 멤버는 클래스 자체와 연관되어 있으며, 클래스의 인스턴스가 생성되기 전에 사용할 수 있습니다. 이는 클래스의 인스턴스와는 별개로 존재하는 멤버이므로, 클래스를 생성하지 않고도 직접 호출할 수 있습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">static</code></strong> 키워드를 사용하여 선언된 정적 멤버는 클래스 이름으로 접근할 수 있습니다. 예를 들어, 다음과 같이 정적 메서드를 선언할 수 있습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">typescriptCopy</span> <span class="nx">code</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="k">static</span> <span class="nf">myStaticMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">This is a static method.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">MyClass</span><span class="p">.</span><span class="nf">myStaticMethod</span><span class="p">();</span> <span class="c1">// 'This is a static method.' 출력</span>

</code></pre></div></div>

<p>정적 멤버로는 메서드 외에도 정적 변수(static variable)를 선언할 수 있습니다. 이 변수는 클래스의 인스턴스마다 개별적으로 존재하는 인스턴스 변수와는 달리 클래스 전체에서 공유되는 변수입니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">typescriptCopy</span> <span class="nx">code</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="k">static</span> <span class="nx">myStaticVariable</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">This is a static variable.</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">myStaticVariable</span><span class="p">);</span> <span class="c1">// 'This is a static variable.' 출력</span>

</code></pre></div></div>

<p>정적 멤버는 클래스의 인스턴스와는 별개로 동작하기 때문에, 클래스 메서드 내에서 정적 멤버에 접근하기 위해서는 <strong><code class="language-plaintext highlighter-rouge">this</code></strong> 대신 클래스 이름을 사용해야 합니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">typescriptCopy</span> <span class="nx">code</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="k">static</span> <span class="nx">myStaticVariable</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">This is a static variable.</span><span class="dl">'</span><span class="p">;</span>

  <span class="k">static</span> <span class="nf">myStaticMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`The static variable is: </span><span class="p">${</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">myStaticVariable</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">MyClass</span><span class="p">.</span><span class="nf">myStaticMethod</span><span class="p">();</span> <span class="c1">// 'The static variable is: This is a static variable.' 출력</span>

</code></pre></div></div>

<p>정적 멤버는 클래스에서 자주 사용되는 상수, 유틸리티 함수, 팩토리 메서드 등을 구현할 때 유용합니다.</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="typescript" /><category term="typescript" /><summary type="html"><![CDATA[public , static 키워드]]></summary></entry><entry><title type="html">브라우저 렌더링 과정</title><link href="http://localhost:4000/cs/browserRendering/" rel="alternate" type="text/html" title="브라우저 렌더링 과정" /><published>2023-03-12T00:00:00+09:00</published><updated>2023-03-12T00:00:00+09:00</updated><id>http://localhost:4000/cs/browserRendering</id><content type="html" xml:base="http://localhost:4000/cs/browserRendering/"><![CDATA[<h1 id="브라우저-렌더링-과정에-대해">브라우저 렌더링 과정에 대해</h1>

<p>우리가 작성한 코드들, HTML , CSS , JavaScript 코드들이 어떻게 렌더링이 되는지에 대해 공부했다.</p>

<p>개발자라면 알아야 하는 내용이며 어렵지 않게 이해할 수 있었다.</p>

<p>자, 그럼 단계에 대해서 알아보자.</p>

<h3 id="1-html-파일을-파싱하고-dom-트리를-구축한다">1. HTML 파일을 파싱하고 DOM 트리를 구축한다.</h3>

<p>여기서 DOM은, Document Object Model의 약자로 HTML 파일과 Script 언어들을 연결시켜줄 때 필요한 모델에 대한 내용이다.
우리가 JavaScript 파일에서 HTML 파일에 있는 요소들을 불러올때 Document.querySelector 뭐 이런거로 불러올 때, 쓰이는 Document객체가 바로 DOM 객체이다.</p>

<h3 id="2-css-파일을-파싱하고-cssom-트리를-구축한다">2. CSS 파일을 파싱하고 CSSOM 트리를 구축한다.</h3>

<p>CSS Object Model 의 약자인 CSSOM, DOM처럼 CSS의 내용을 해석하고 노드를 만들어 트리구조로 만든다.</p>

<h3 id="3-javascript를-실행한다">3. JavaScript를 실행한다.</h3>

<p>주의할 점은, HTML 파일 중간에 스크립트가 들어가있으면 HTML 파싱이 중단이 된다는 점이다.</p>

<p>때문에 script를 src 속성을 통해 HTML 파일에 연결할때, <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 태그의 가장 끝에다가 몰아서 두는 것이다.</p>

<h3 id="4-dom-과-cssom-트리를-조합해서-렌더-트리를-구축한다">4. DOM 과 CSSOM 트리를 조합해서 렌더 트리를 구축한다.</h3>

<p>이때, <code class="language-plaintext highlighter-rouge">display: none;</code> 과 같은 속성들은 렌더트리에 포함되지 않는다.</p>

<h3 id="5-viewport-를-기준으로-렌더트리의-각-노드가-가지는-정확한-위치와-크기를-계산한다">5. ViewPort 를 기준으로 렌더트리의 각 노드가 가지는 정확한 위치와 크기를 계산한다.</h3>

<h3 id="6-계산된-위치와-크기를-기반으로-화면에-그린다-paint-과정">6. 계산된 위치와 크기를 기반으로 화면에 그린다 (Paint 과정)</h3>

<hr />

<ol>
  <li>HTML 파일을 파싱하여 DOM 트리를 구축한다.</li>
  <li>CSS 파일을 파싱하여 CSSOM 트리를 구축한다.</li>
  <li>JS 파일을 실행한다.</li>
  <li>DOM 트리와 CSSOM 트리를 합쳐서 렌더트리를 구축한다.</li>
  <li>ViewPort를 기준으로 렌더트리의 각 노드가 가지는 정확한 위치와 크기를 계산한다.</li>
  <li>계산된 위치, 크기를 조정하여 화면에 그린다.</li>
</ol>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="cs" /><category term="cs" /><summary type="html"><![CDATA[브라우저 렌더링 과정에 대해]]></summary></entry><entry><title type="html">rest parameter, object자료형의 파라미터</title><link href="http://localhost:4000/typescript/typescriptStudy/" rel="alternate" type="text/html" title="rest parameter, object자료형의 파라미터" /><published>2023-03-12T00:00:00+09:00</published><updated>2023-03-12T00:00:00+09:00</updated><id>http://localhost:4000/typescript/typescriptStudy</id><content type="html" xml:base="http://localhost:4000/typescript/typescriptStudy/"><![CDATA[<p>이전 강의에서 진행했던 예제였던 것중에 중요했던 개념이다. rest parameter</p>

<p>rest parameter와 object 자료형의 파라미터는, 구조분해 할당에 대한 이해와 spread 문법에 대해 아는 것부터 필요하다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">숫자1</span><span class="p">,</span> <span class="nx">숫자2</span><span class="p">,</span> <span class="nx">숫자3</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr1</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">숫자1</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">숫자2</span><span class="p">)</span> <span class="c1">// 2</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">숫자3</span><span class="p">)</span> <span class="c1">// 3</span>

</code></pre></div></div>

<p>구조분해할당의 가장 기초적인 개념이다. 선언된 [숫자1, 숫자2, 숫자3] 이</p>

<p><code class="language-plaintext highlighter-rouge">let 숫자1 = arr1[0]</code> , <code class="language-plaintext highlighter-rouge">let 숫자2 = arr[1]</code>, <code class="language-plaintext highlighter-rouge">let 숫자3 = arr[2]</code> 과 같은 역할을 하는건데, 한줄로 표현되니깐 참 코드가 간결해진다.</p>

<p>spread 문법은</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>

<span class="kd">let</span> <span class="nx">arr3</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arr1</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr2</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">arr3</span><span class="p">);</span> <span class="c1">// [1,2,3,4,5]</span>
</code></pre></div></div>

<p>… 을 붙이면, 배열이나 객체 자료형을 풀어서 쓴다(?) 벗겨준다(?)의 의미로 이해했다.</p>

<p>때문에 arr3은, arr1의 [] arr2의 [] 이 풀어서 써졌기에, [1,2,3,4,5] 의 결과를 갖는 것이다.</p>

<p>react 를 공부할때, object 자료형의 state에 무언가 추가될때</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{...</span><span class="nx">state</span><span class="p">,</span> <span class="nx">추가되는</span> <span class="nx">속성</span><span class="p">}</span>
</code></pre></div></div>

<p>이렇게 쓰는게, 원래 object 자료형에있던 state가 앞에 풀려지고, 뒤에 추가되는 속성을 써서 다시 object자료형으로 묶어서 합쳐주는 느낌. 그게 spread 문법이다.</p>

<p>그래서, rest parameter는 무엇인가.</p>

<p>전에 풀었던 예제에서 파라미터가 하나 두개가 아닌 사용자가 입력하는 대로 받아들여질때, 3개든 100개든 상관없이 들어갈 수 있는 함수를 만든다고 할때 rest parameter를 써야한다.</p>

<p>어떻게 쓰냐면</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="p">(...</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">junyub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">));</span> <span class="c1">// [1,2,3,4,5]</span>
</code></pre></div></div>

<p>이렇게 파라미터 자리에 spread 문법을 써버리는 것이다. 그럼 a 라는 파라미터로 입력된 데이터는 array 형태로 받아진다.</p>

<p>그럼, rest parameter에 대한 타입은 어떻게 지정하는가?</p>

<p>그 데이터가 배열로 받아진다 했으니, 배열 타입 선언하듯이 만들면 된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="p">(...</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>물론 union type으로 타입을 선언해도 되겠다.</p>

<p>그렇게 받아진 여러개의 데이터를 갖는 파라미터는 forEach, map, filter 등 array 자료형에서 쓸 수 있는 메서드들을 활용할 수 있다.</p>

<p>Narrowing 할때 많이 쓰인다.</p>

<h2 id="그럼-파라미터가-object로-들어가려면">그럼 파라미터가 object로 들어가려면</h2>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">lee</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">}</span>

<span class="kd">function</span> <span class="nf">junyub</span> <span class="p">({</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">}){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">junyub</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span> <span class="c1">// "lee" \n 30</span>
</code></pre></div></div>

<p>파라미터 자리에 object 자료형이 들어오면, 구조분해할당 문법대로 써주면 된다.</p>

<p>객체를 미리 파라미터에 넣어놓으면 된다.</p>

<p>타입지정하려면 object 자료형에 타입지정하듯이 하면 된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="p">({</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">}:</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">}){</span>
  <span class="nx">블라블라</span>
<span class="p">}</span>
</code></pre></div></div>

<p>근데 객체 타입지정해줄때는 보통 type alias 나 interface 써줬으니 미리 선언해놓고 쓰면 되겠다.</p>

<h1 id="narrowing-할때-null이나-undefined-체크할때">narrowing 할때 null이나 undefined 체크할때</h1>

<p>typeof 써서 <code class="language-plaintext highlighter-rouge">if(typeof 변수 === "string")</code> 이런식으로 썼는데, 생각보다 undefined 체크하는 narrowing이 많다고 한다.</p>

<p>개발자들은 간결한 코드를 좋아해서 또 간결하게 해결하는 법을 알려줬다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if</span><span class="p">(</span><span class="nx">변수</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">변수</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">실행문</span>
<span class="p">}</span>
</code></pre></div></div>

<p>조건식에 이렇게 쓰면, 변수가 undefined면 undefined를 반환시키도록하고, string이면 실행문을 실행시켜주는 역할을 한다고 한다.</p>

<p>이전에 js 배울때 &amp;&amp; 조건연산자 쓰면 and , 양쪽 둘다 참이면 이라는 의미였는데 아마 동일하지 않을까 생각한다.</p>

<p>변수라는 애가 값이 있으면 undefined가 아닐거니깐 typeof 변수 === “string” 이라는 조건도 함께 충족되니 실행문에 접근이 될거고</p>

<p>변수라는애가 값이 없으면 undefined가 되니깐 양쪽 다 참이 안되니 실행문에 접근이 안될 것이라고 본다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Jun</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>
<span class="kd">type</span> <span class="nx">Yub</span> <span class="o">=</span> <span class="p">{</span> <span class="na">weight</span><span class="p">:</span> <span class="mi">100</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nf">lee</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">Jun</span> <span class="o">|</span> <span class="nx">Yub</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">Jun</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// 이런건 없음</span>
<span class="p">}</span>
</code></pre></div></div>

<p>typeof 연산자는, type alias 에 대한 타입을 검사해주지는 않는다. 기본 자료형만 해준다. number string boolean 같은,,</p>

<p>때문에 type alias를 쓴 타입인지에 대해 narrowing을 하려면 !</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Jun</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>
<span class="kd">type</span> <span class="nx">Yub</span> <span class="o">=</span> <span class="p">{</span> <span class="na">weight</span><span class="p">:</span> <span class="mi">100</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nf">lee</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">Jun</span> <span class="o">|</span> <span class="nx">Yub</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if</span><span class="p">(</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">Jun</span><span class="p">){</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">in</code> 키워드를 써주면 된다. 문법 자체는 <code class="language-plaintext highlighter-rouge">속성명 in object자료</code> 순으로 작성한다.</p>

<p>Jun 이라는 type에 속성이 age 니깐, age가 Jun에 있냐? , 참이라면 x 타입이 Jun 인거니깐. narrowing이 된다.</p>

<p>단, 두 type alias에서 정의된 속성이 서로 다를 때에만 <code class="language-plaintext highlighter-rouge">in</code> 키워드를 사용할 수 있다.</p>

<h3 id="class-로-사용되면-instanceof-연산자-써서-해주면-된다">class 로 사용되면 instanceof 연산자 써서 해주면 된다.</h3>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">날짜</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span>
<span class="nf">if</span><span class="p">(</span><span class="nx">날짜</span> <span class="k">instanceof</span> <span class="nb">Date</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">참입니다</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>날짜 라고 쓴 변수가 Date class의 인스턴스이냐? 라고 조건식이 걸리는 거고, 참이면 실행문에 접근되니 이게 narrowing 이다.</p>

<p>중복되는 속성들이 있을때엔, Literal type이 있으면 narrowing이 쉽다. (당연한것)</p>

<h2 id="never-타입은-언제-쓰이는가">never 타입은 언제 쓰이는가?</h2>

<p>주로 안쓰인다. 개발자가 코드를 잘못 입력했을 때 간혹 never타입이 지정되곤 하는데, 이런 타입은 있을 수 없다는 의미로 받아들이면 된다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Jun</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">Yub</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">JunYub</span> <span class="o">=</span> <span class="nx">Jun</span> <span class="o">&amp;</span> <span class="nx">Yub</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">yubmun</span><span class="p">:</span> <span class="nx">JunYub</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span> <span class="c1">// error, age는 never타입</span>
</code></pre></div></div>

<p>type alias 에서, 속성명이 중복되고 타입이 다를 때, never 타입이 적용되곤 한다.</p>

<table>
  <tbody>
    <tr>
      <td>age가 number</td>
      <td>string 타입이 아닌, never 타입이 되는 이유는 string도 되고 number도 되는 타입이 없기 때문이다.</td>
    </tr>
  </tbody>
</table>

<p>함수에서도 never 타입이 써진다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">junyub</span><span class="p">()</span> <span class="p">:</span><span class="nx">never</span> <span class="p">{</span>
	
<span class="p">}</span>
</code></pre></div></div>

<p>return type 이 never 이면, return이 이루어지면 안된다는 의미로 함수가 끝나지 않는다는 것을 의미하거나 return 하는게 없는 함수임을 의미한다.</p>

<p>return 하는게 없을 때엔 never 타입보다는 void 타입을 더 많이 사용한다.</p>

<p>never 타입이 return 타입일때엔, 함수가 에러를 던지거나, 무한반복문으로 인해 끝나지 않을때 (end point 가 없을 때) 선언된다.</p>

<p>내 코드에 never 타입이 있다면, 코드를 잘못짠거라고 생각하면 되겠다.</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="typescript" /><category term="typescript" /><summary type="html"><![CDATA[이전 강의에서 진행했던 예제였던 것중에 중요했던 개념이다. rest parameter]]></summary></entry><entry><title type="html">카테고리 설정!</title><link href="http://localhost:4000/practice/practice/" rel="alternate" type="text/html" title="카테고리 설정!" /><published>2023-03-05T00:00:00+09:00</published><updated>2023-03-05T00:00:00+09:00</updated><id>http://localhost:4000/practice/practice</id><content type="html" xml:base="http://localhost:4000/practice/practice/"><![CDATA[<h1 id="카테고리를-설정해봅니다">카테고리를 설정해봅니다.</h1>

<h2 id="목차에서는-어떻게-표시가-되는가">목차에서는 어떻게 표시가 되는가?</h2>

<p>카테고리 설정이 되겠쥬?</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="practice" /><category term="typescript" /><summary type="html"><![CDATA[카테고리를 설정해봅니다.]]></summary></entry><entry><title type="html">작성해보는 첫 게시글!</title><link href="http://localhost:4000/practice/first/" rel="alternate" type="text/html" title="작성해보는 첫 게시글!" /><published>2023-03-04T00:00:00+09:00</published><updated>2023-03-04T00:00:00+09:00</updated><id>http://localhost:4000/practice/first</id><content type="html" xml:base="http://localhost:4000/practice/first/"><![CDATA[<h1 id="깃-블로그-어렵지-않다">깃 블로그 어렵지 않다</h1>

<p><strong>Hello world</strong>, this is my first Jekyll blog post.</p>

<p>I hope you like it!</p>]]></content><author><name>Yubmun</name><email>dlwnsduq23@gmail.com</email></author><category term="practice" /><summary type="html"><![CDATA[깃 블로그 어렵지 않다]]></summary></entry></feed>